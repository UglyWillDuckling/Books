<?xml version='1.0' encoding='utf-8'?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="uuid_id" version="2.0">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
        <dc:identifier opf:scheme="calibre" id="calibre_id">88</dc:identifier>
        <dc:identifier opf:scheme="uuid" id="uuid_id">3c31bcd0-0ea7-4437-95b8-20712ccf100b</dc:identifier>
        <dc:title>Object-Oriented Software Construction</dc:title>
        <dc:creator opf:file-as="Meyer, Bertrand" opf:role="aut">Bertrand Meyer</dc:creator>
        <dc:contributor opf:file-as="calibre" opf:role="bkp">calibre (6.13.0) [https://calibre-ebook.com]</dc:contributor>
        <dc:date>2000-03-21T00:00:00+00:00</dc:date>
        <dc:description>&lt;h3&gt;Amazon.com Review&lt;/h3&gt;
&lt;p&gt;The developer of the acclaimed Eiffel programming language comes through with one of the clearest and most informative books about computers ever committed to paper. &lt;em&gt;Object-Oriented Software Construction&lt;/em&gt; is the gospel of object-oriented technology and it deserves to be spread everywhere. Meyer opens with coverage of the need for an object-oriented approach to software development, citing improved quality and development speed as key advantages of the approach. He then explains all the key criteria that define an object- oriented approach to a problem. Meyer pays attention to techniques, such as classes, objects, memory management, and more, returning to each technique and polishing his readers' knowledge of it as he explains how to employ it "well." In a section on advanced topics, Meyer explores interesting and relevant topics, such as persistent objects stored in a database. He also offers a sort of "Do and Don't" section in which he enumerates common mistakes and ways to avoid them. Management information isn't the main point of &lt;em&gt;Object-Oriented Software Construction&lt;/em&gt; , but you'll find some in its pages. Meyer concludes his tour de force with comparisons of all the key object-oriented languages, including Java. He also covers the potential of simulating object technology in non-object-oriented languages, such as Pascal and Fortran. The companion CD-ROM includes the full text of this book in hypertext form, as well as some tools for designing object-oriented systems. If you program computers, you need to read this book.&lt;/p&gt;
&lt;h3&gt;Product Description&lt;/h3&gt;
&lt;p&gt;This is, quite simply, the definitive reference on the most important development in software technology for the last 20 years: object-orientation.A whole generation was introduced to object technology through the first edition of this book. This long-awaited new edition retains the qualities of clarity, practicality and scholarship that made the first an instant best-seller, but has been thoroughly revised and expanded. Among the new topics covered in depth are: Concurrency, distribution, client/server and the Internet; object-oriented databases; design by contract; fundamental design patterns; finding classes; the use and misuse of inheritance; abstract data types; and typing issues. The book also includes completely updated discussions of reusability, modularity, software quality, object-oriented languages, memory management, and many other essential topics.All software developers and computer science students, worldwide. &lt;/p&gt;
&lt;h3&gt;From the Publisher&lt;/h3&gt;
&lt;p&gt;The comprehensive reference on all aspects of object technology, from design principles to O-O techniques, Design by Contract, O-O analysis, concurrency, persistence, abstract data types and many more. Written by a pioneer in the field, contains an in-depth analysis of both methodological and technical issues. Comes with a CD-ROM containing: the complete hyperlinked text, for easy reference; software to read the text on major industry platforms; supplementary material (reusable components, mathematical complements); and a complete graphical O-O development environment supporting the concepts of the book.&lt;/p&gt;
&lt;h3&gt;From the Inside Flap&lt;/h3&gt;
&lt;p&gt;Preface   &lt;/p&gt;
&lt;p&gt;Born in the ice-blue waters of the festooned Norwegian coast; amplified (by an aberration of world currents, for which marine geographers have yet to find a suitable explanation) along the much grayer range of the Californian Pacific; viewed by some as a typhoon, by some as a tsunami, and by some as a storm in a teacup — a tidal wave is hitting the shores of the computing world.   &lt;/p&gt;
&lt;p&gt;“Object-oriented” is the latest in term, complementing and in many cases replacing “structured” as the high-tech version of “good” . As is inevitable in such a case, the term is used by different people with different meanings; just as inevitable is the well-known three-step sequence of reactions that meets the introduction of a new methodological principle: (1) “it's trivial” ; (2) “it cannot work” ; (3) “that's how I did it all along anyway” . (The order may var y.)   &lt;/p&gt;
&lt;p&gt;Let us have this clear right away, lest the reader think the author takes a half-hearted approach to his topic: I do not see the object-oriented method as a mere fad; I think it is not trivial (although I shall strive to make it as limpid as I can); I know it works; and I believe it is not only different from but even, to a certain extent, incompatible with the techniques that most people still use today — including some of the principles taught in many software engineering textbooks. I further believe that object technology holds the potential for fundamental changes in the software industry, and that it is here to stay. Finally, I hope that as the reader progresses through these pages, he will share some of my excitement about this promising avenue to software analysis, design and implementation.   &lt;/p&gt;
&lt;p&gt;“Avenue to software analysis, design and implementation” . To present the object-oriented method, this books resolutely takes the viewpoint of software engineering — of the methods, tools and techniques for developing quality software in production environments. This is not the only possible perspective, as there has also been interest in applying object-oriented principles to such areas as exploratory programming and artificial intelligence. Although the presentation does not exclude these appli cations, they are not its main emphasis. Our principal goal in this discussion is to study how practicing software developers, in industrial as well as academic environments, can use object technology to improve (in some cases dramatically) the quality of the software they produce.   &lt;/p&gt;
&lt;p&gt;Structure, reliability, epistemology and classification. &lt;br /&gt;
Object technology is at its core the combination of four ideas: a structuring method, a reliability discipline, an epistemological principle and a classification technique.   &lt;/p&gt;
&lt;p&gt;The structuring method applies to software decomposition and reuse. Software systems perform certain actions on objects of certain types; to obtain flexible and reusable systems, it is better to base their structure on the object types than on the actions. The resulting concept is a remarkably powerful and versatile mechanism called the class, which in object-oriented software construction serves as the basis for both the modular structure and the type system.   &lt;/p&gt;
&lt;p&gt;The reliability discipline is a radical approach to the problem of building software that does what it is supposed to do. The idea is to treat any system as a collection of components which collaborate the way successful businesses do: by adhering to contracts defining explicitly the obligations and benefits incumbent on each party.   &lt;/p&gt;
&lt;p&gt;Abstract data types are discussed in chapter 6, which also addresses some of the related epistemological issues. &lt;br /&gt;
The epistemological principle addresses the question of how we should describe the classes. In object technology, the objects described by a class are only defined by what we can do with them: operations (also known as features) and formal properties of these operations (the contracts). This idea is formally expressed by the theory of abstract data types, covered in detail in a chapter of this book. It has far-reaching implications, some going beyond software, and explains why we must not stop at the na•ve concept of “object” borrowed from the ordinary meaning of that word. The tradition of information systems modeling usually assumes an “external reality” that predates any program using it; for the object-oriented developer, such a notion is meaningless, as the reality does not exist independently of what you want to do with it. (More precisely whether it exists or not is an irrelevant question, as we only know what we can use, and what we know of something is defined entire ly by how we can use it.)   &lt;/p&gt;
&lt;p&gt;The classification technique follows from the observation that systematic intellectual work in general and scientific reasoning in particular require devising taxonomies for the domains being studied. Software is no exception, and the object-oriented method relies heavily on a classification discipline known as inheritance.   &lt;/p&gt;
&lt;p&gt;Simple but powerful. &lt;br /&gt;
The four concepts of class, contract, abstract data type and inheritance immediately raise a number of questions. How do we find and describe classes? How should our programs manipulate classes and the corresponding objects (the instances of these classes)? What are the possible relations between classes? How can we capitalize on the commonalities that may exist between various classes? How do these ideas relate to such key software engineering concerns as extendibility, ease of use and efficiency?   &lt;/p&gt;
&lt;p&gt;Answers to these questions rely on a small but powerful array of techniques for producing reusable, extendible and reliable software: polymorphism and dynamic binding; a new view of types and type checking; genericity, constrained and unconstrained; information hiding; assertions; safe exception handling; automatic garbage collection. Efficient implementation techniques have been developed which permit applying these ideas successfully to both small and large projects under the tight constraints of commerci al software development. Object-oriented techniques have also had a considerable impact on user interfaces and development environments, making it possible to produce much better interactive systems than was possible before. All these important ideas will be studied in detail, so as to equip the reader with tools that are immediately applicable to a wide range of problems.   &lt;/p&gt;
&lt;p&gt;Organization of the text. &lt;br /&gt;
In the pages that follow we will review the methods and techniques of object-oriented software construction. The presentation has been divided into six parts.   &lt;/p&gt;
&lt;p&gt;Chapters 1 to 2: Part A is an introduction and overview. It starts by exploring the fundamental issue of software quality and continues with a brief survey of the method's main technical characteristics. This part is almost a little book by itself, providing a first view of the object-oriented approach for hurried readers.   &lt;/p&gt;
&lt;p&gt;Chapters 3 to 6: Part B is not hurried. Entitled “The road to object orientation” , it takes the time to describe the methodological concerns that lead to the central O-O concepts. Its focus is on modularity: what it takes to devise satisfactory structures for “in-the-large” system construction. It ends with a presentation of abstract data types, the mathematical basis for object technology. The mathematics involved is elementary, and less mathematically inclined readers may content themselves with the basic ideas, but the presentation provides the theoretical background that you will need for a full understanding of O-O principles and issues.   &lt;/p&gt;
&lt;p&gt;Chapters 7 to 18: Part C is the technical core of the book. It presents, one by one, the central technical components of the method: classes; objects and the associated run-time model; memory management issues; genericity and typing; design by contract, assertions, exceptions; inheritance, the associated concepts of polymorphism and dynamic binding, and their many exciting applications.   &lt;/p&gt;
&lt;p&gt;Chapters 19 to 29: Part D discusses methodology, with special emphasis on analysis and design. Through several in-depth case studies, it presents some fundamental design patterns, and covers such central questions as how to find the classes, how to use inheritance properly, and how to design reusable libraries. It starts with a meta-level discussion of the intellectual requirements on methodologists and other advice-givers; it concludes with a review of the software process (the lifecycle model) for O-O development and a disc ussion of how best to teach the method in both industry and universities.   &lt;/p&gt;
&lt;p&gt;Chapters 30 to 32: Part E explores advanced topics: concurrency, distribution, client-server development and the Internet; persistence, schema evolution and object-oriented databases; the design of interactive systems with modern (“GUI” ) graphical interfaces.   &lt;/p&gt;
&lt;p&gt;Chapters 33 to 35. Part F is a review of how the ideas can be implemented, or in some cases emulated, in various languages and environments. This includes in particular a discussion of major object-oriented languages, focusing on Simula, Smalltalk, Objective-C, C++, Ada 95 and Java, and an assessment of how to obtain some of the benefits of object orientation in such non-O-O languages as Fortran, Cobol, Pascal, C and Ada.   &lt;/p&gt;
&lt;p&gt;Chapter 36. Part G (doing it right) describes an environment which goes beyond these solutions and provides an integrated set of tools to support the ideas of the book.   &lt;/p&gt;
&lt;p&gt;Appendix A. As complementary reference material, an appendix shows some important reusable library classes discussed in the text, providing a model for the design of reusable software.   &lt;/p&gt;
&lt;p&gt;A Book-Wide Web &lt;br /&gt;
It can be amusing to see authors taking pains to describe recommended paths through their books, sometimes with the help of sophisticated traversal charts — as if readers ever paid any attention, and were not smart enough to map their own course. An author is permitted, however, to say in what spirit he has scheduled the different chapters, and what path he had in mind for what Umberto Eco calls the Model Reader — not to be confused with the real reader, also known as “you” , made of flesh, b lood and tastes.   &lt;/p&gt;
&lt;p&gt;The answer here is the simplest possible one. This book tells a story, and assumes that the Model Reader will follow that story from beginning to end, being however invited to avoid the more specialized sections marked as “skippable on first reading” and, if not mathematically inclined, to ignore a few mathematical developments also labeled explicitly. The real reader, of course, may want to discover in advance some of the plot's later developments, or to confine his attention to just a few subplots ; every chapter has for that reason been made as self-contained as possible, so that you should be able to intake the material at the exact dosage which suits you best.   &lt;/p&gt;
&lt;p&gt;Because the story presents a coherent view of software development, its successive topics are tightly intertwined. The margin notes offer a subtext of cross references, a Book-Wide Web linking the various sections back and forth. My advice to the Model Reader is to ignore them on first reading, except as a reassurance that questions which at some stage are left partially open will be fully closed later on. The real reader, who may not want any advice, might use the cross references as unofficial guides when he feels like cheating on the prearranged order of topics.   &lt;/p&gt;
&lt;p&gt;Both the Model Reader and the real reader should find the cross references mostly useful in subsequent readings, to make sure that they have mastered a certain object-oriented concept in depth, and understood its connections with the method's other components. Like the hyperlinks of a WWW document, the cross references should make it possible to follow such associations quickly and effectively.   &lt;/p&gt;
&lt;p&gt;See "About the accompanying CD-ROM", page xiv. The CD-ROM that accompanies this book and contains all of its text provides a convenient way to follow cross references: just click on them. All the cross references have been preserved.   &lt;/p&gt;
&lt;p&gt;The notation &lt;br /&gt;
In software perhaps even more than elsewhere, thought and language are closely connected. As we progress through these pages, we will carefully develop a notation for expressing object-oriented concepts at all levels: modeling, analysis, design, implementation, maintenance.   &lt;/p&gt;
&lt;p&gt;Here and everywhere else in this book, the pronoun “we” does not mean “the author” : as in ordinary language, “we” means you and I — the reader and the author. In other words I would like you to expect that, as we develop the notation, you will be involved in the process.   &lt;/p&gt;
&lt;p&gt;This assumption is not really true, of course, since the notation existed before you started reading these pages. But it is not completely preposterous either, because I hope that as we explore the object-oriented method and carefully examine its implications the supporting notation will dawn on you with a kind of inevitability, so that you will indeed feel that you helped design it.   &lt;/p&gt;
&lt;p&gt;This explains why although the notation has been around for more than ten years and is in fact supported by several commercial implementations, including one from my company (ISE), I have downplayed it as a language. (Its name does appear in one place in the text, and several times in the bibliography.) This book is about the object-oriented method for reusing, analyzing, designing, implementing and maintaining software; the language is an important and I hope natural consequence of that method, not an aim in itself.   &lt;/p&gt;
&lt;p&gt;In addition, the language is straightforward and includes very little else than direct support for the method. First-year students using it have commented that it was “no language at all” — meaning that the notation is in one-to-one correspondence with the method: to learn one is to learn the other, and there is scant extra linguistic decoration on top of the concepts. The notation indeed shows few of the peculiarities (often stemming from historical circumstances, machine constraints or the req uirement to be compatible with older formalisms) that characterize most of today's programming languages. Of course you may disagree with the choice of keywords (why do rather than begin or perhaps faire?), or would like to add semicolon terminators after each instruction. (The syntax has been designed so as to make semicolons optional.) But these are side issues. What counts is the simplicity of the notation and how directly it maps to the concepts. If you understand object technology, you almost know it a lready.   &lt;/p&gt;
&lt;p&gt;Most software books take the language for granted, whether it is a programming language or a notation for analysis or design. Here the approach is different; involving the reader in the design means that one must not only explain the language but also justify it and discuss the alternatives. Most of the chapters of part C include a “discussion” section explaining the issues encountered during the design of the notation, and how they were resolved. I often wished, when reading descriptions of well-kn own languages, that the designers had told me not only what solutions they chose, but why they chose them, and what alternatives they rejected. The candid discussions included in this book should, I hope, provide you with insights not only about language design but also about software construction, as the two tasks are so strikingly similar.   &lt;/p&gt;
&lt;p&gt;Analysis, design and implementation &lt;br /&gt;
It is always risky to use a notation that externally looks like a programming language, as this may suggest that it only covers the implementation phase. This impression, however wrong, is hard to correct, so frequently have managers and developers been told that a gap of metaphysical proportions exists between the ether of analysis-design and the underworld of implementation.   &lt;/p&gt;
&lt;p&gt;SEAMLESSNESS AND REVERSIBILITY:, 28.6, page 930. Well-understood object technology reduces the gap considerably by emphasizing the essential unity of software development over the inevitable differences between levels of abstraction. This seamless approach to software construction is one of the important contributions of the method and is reflected by the language of this book, which is meant for analysis and design as well as for implementation.   &lt;/p&gt;
&lt;p&gt;Unfortunately some of the recent evolution of the field goes against these principles, through two equally regrettable phenomena: &lt;br /&gt;
Object-oriented implementation languages which are unfit for analysis, for design and in general for high-level reasoning. &lt;br /&gt;
Object-oriented analysis or design methods which do not cover implementation (and are advertized as “language-independent” as if this were a badge of honor rather than an admission of failure).   &lt;/p&gt;
&lt;p&gt;Such approaches threaten to cancel much of the potential benefit of the approach. In contrast, both the method and the notation developed in this book are meant to be applicable throughout the software construction process. A number of chapters cover high-level design issues; one is devoted to analysis; others explore implementation techniques and the method's implications on performance.   &lt;/p&gt;
&lt;p&gt;The environment &lt;br /&gt;
Software construction relies on a basic tetralogy: method, language, tools, libraries. The method is at the center of this book; the language question has just been mentioned. Once in a while we will need to see what support they may require from tools and libraries. For obvious reasons of convenience, such discussions will occasionally refer to ISE's object-oriented environment, with its set of tools and associated libraries.   &lt;/p&gt;
&lt;p&gt;The last chapter, 36, summarizes the environment. The environment is used only as an example of what can be done to make the concepts practically usable by software developers. Be sure to note that there are many other object-oriented environments available, both for the notation of this book and for other O-O analysis, design and implementation methods and notations; and that the descriptions given refer to the state of the environment at the time of writing, subject, as anything else in our industry, to change quickly — for the better. Other environm ents, O-O and non O-O, are also cited throughout the text.   &lt;/p&gt;
&lt;p&gt;Acknowledgments (quasi-absence thereof) &lt;br /&gt;
The first edition of this book contained an already long list of thanks. For a while I kept writing down the names of people who contributed comments or suggestions, and then at some stage I lost track. The roster of colleagues from whom I have had help or borrowed ideas has now grown so long that it would run over many pages, and would inevitably omit some important people. Better then offend everyone a little than offend a few very much.   &lt;/p&gt;
&lt;p&gt;A few notes in the margin or in chapter-end bibliographic sections give credit for some specific ideas, often unpublished. So these acknowledgments will for the most part remain collective, which does not make my gratitude less deep. My colleagues at ISE and SOL have for years been a daily source of invaluable help. The users of our tools have generously provided us with their advice. The readers of the first edition provided thousands of suggestions for improvement. In the preparation of this new edition (I should really say of this new book) I have sent hundreds of e-mail messages asking for help of many different kinds: the clarification of a fine point, a bibliographical reference, a permission to quote, the details of an attribution, the origin of an idea, the specifics of a notation, the official address of a Web page; the answers have invariably been positive. As draft chapters were becoming ready they were circulated through various means, prompting many constructive comments (and here I must cite by name the referees commissioned by Prentice Hall, Paul Dubois, James McKim and Richard Wiener, who provided invaluable advic e and corrections). In the past few years I have given countless seminars, lectures and courses about the topics of this book, and in every case I learned something from the audience. I enjoyed the wit of fellow panelists at conferences and benefited from their wisdom. Short sabbaticals at the University of Technology, Sydney and the Universita degli Studi di Milano provided me with a influx of new ideas — and in the first case with three hundred first-year students on whom to validate some of my ideas about how software engineering should be taught.   &lt;/p&gt;
&lt;p&gt;The large bibliography shows clearly enough how the ideas and realizations of others have contributed to this book. Among the most important conscious influences are the Algol line of languages, with its emphasis on syntactic and semantic elegance; the seminal work on structured programming, in the serious (Dijkstra-Hoare-Parnas-Wirth-Mills-Gries) sense of the term, and systematic program construction; formal specification techniques, in particular the inexhaustible lessons of Jean-Raymond Abrial's original (late nineteen-seventies) version of the Z specification language, his more recent design of B, and Cliff Jones's work on VDM; the languages of the modular generation (in particular Ichbiah's Ada, Liskov's CLU, Shaw's Alphard, Bert's LPG and Wirth's Modula); and Simula 67, which introduced most of the concepts many years ago and had most of them right, bringing to mind Tony Hoare's comment about Algol 60: that it was such an improvement over most of its successors.   &lt;/p&gt;
&lt;p&gt;Foreword to the second edition: &lt;br /&gt;
M any events have happened in the object-oriented world since the first edition of OOSC (as the book came to be known) was published in 1988. The explosion of interest alluded to in the Preface to the first edition, reproduced in the preceding pages in a slightly expanded form, was nothing then as compared to what we have seen since. Many journals and conferences now cover object technology; Prentice Hall has an entire book series devoted to the subject; breakthroughs have occurred in such areas as user int erfaces, concurrency and databases; entire new topics have emerged, such as O-O analysis and formal specification; distributed computing, once a specialized topic, is becoming relevant to more and more developments, thanks in part to the growth of the Internet; and the Web is affecting everyone's daily work.   &lt;/p&gt;
&lt;p&gt;This is not the only exciting news. It is gratifying to see how much progress is occurring in the software field — thanks in part to the incomplete but undeniable spread of object technology. Too many books and articles on software engineering still start with the obligatory lament about the “software crisis” and the pitiful state of our industry as compared to true engineering disciplines (which, as we all know, never mess things up). There is no reason for such doom. Oh, we still have a long, long way to go, as anyone who uses software products knows all too well. But given the challenges that we face we have no reason to be ashamed of ourselves as a profession; and we are getting better all the time. It is the ambition of this book, as it was of its predecessor, to help in this process.   &lt;/p&gt;
&lt;p&gt;This second edition is not an update but the result of a thorough reworking. Not a paragraph of the original version has been left untouched. (Hardly a single line, actually.) Countless new topics have been added, including a whole chapter on concurrency, distribution, client-server computing and Internet programming; another on persistence and databases; one on user interfaces; one on the software lifecycle; many design patterns and implementation techniques; an in-depth exploration of a methodological iss ue on which little is available in the literature, how to use inheritance well and avoid misusing it; discussions of many other topics of object-oriented methodology; an extensive presentation of the theory of abstract data types — the mathematical basis for our subject, indispensable to a complete understanding of object technology yet seldom covered in detail by textbooks and tutorials; a presentation of O-O analysis; hundreds of new bibliographic and Web site references; the description of a complete object-oriented development environment (also included on the accompanying CD-ROM for the reader's enjoyment) and of the underlying concepts; and scores of new ideas, principles, caveats, explanations, figures, examples, comparisons, citations, classes, routines.   &lt;/p&gt;
&lt;p&gt;The reactions to OOSC-1 have been so rewarding that I know readers have high expectations. I hope they will find OOSC-2 challenging, useful, and up to their standards. Santa Barbara. &lt;br /&gt;
B.M. January 1997   &lt;/p&gt;
&lt;p&gt;About the accompanying CD-ROM: &lt;br /&gt;
The CD-ROM that comes with this book contains the entire hyperlinked text in Adobe Acrobat format. It also includes Adobe's Acrobat Reader software, enabling you to read that format; the versions provided cover major industry platforms. If you do not already have Acrobat Reader on your computer, you can install it by following the instructions. The author and the publisher make no representations as to any property of Acrobat and associated tools; the Acrobat Reader is simply provided as a service to reader s of this book, and any Acrobat questions should be directed to Adobe. You may also check with Adobe about any versions of the Reader that may have appeared after the book.   &lt;/p&gt;
&lt;p&gt;To get started with the CD-ROM, open the Acrobat file README.pdf in the OOSC-2 directory, which will direct you to the table of contents and the index. You can only open that file under Acrobat Reader; if the Reader has not been installed on your computer, examine instead the plain-text version in the file readme.txt in the top-level directory.   &lt;/p&gt;
&lt;p&gt;The presence of an electronic version will be particularly useful to readers who want to take advantage of the thousands of cross-references present in this book (see “A Book-Wide Web” , page viii). Although for a first sequential reading you will probably prefer to follow the paper version, having the electronic form available on a computer next to the book alllows you to follow a link once in a while without having to turn pages back and forth. The electronic form is particularly convenient for a l ater reading during which you may wish to explore links more systematically.   &lt;/p&gt;
&lt;p&gt;All links (cross-references) appear in blue in the Acrobat form, as illustrated twice above (but not visible in the printed version). To follow a link, just click on the blue part. If the reference is to another chapter, the chapter will appear in a new window. The Acrobat Reader command to come back to the previous position is normally Control-minus-sign (that is, type Ð while holding down the CONTROL key). Consult the on-line Acrobat Reader documentation for other useful navigational commands.   &lt;/p&gt;
&lt;p&gt;Bibliographical references also appear as links, such as Knuth 1968, in the Acrobat form, so that you can click on any of them to see the corresponding entry in the bibliography of appendix E. &lt;br /&gt;
The CD-ROM also contains: &lt;br /&gt;
Library components providing extensive material for Appendix A. A chapter from the manual for a graphical application builder, providing mathematical complements to the material of chapter 32. &lt;br /&gt;
In addition, the CD-ROM includes a time-limited version of an advanced object-oriented development environment for Windows 95 or Windows NT, as described in chapter 36, providing an excellent hands-on opportunity to try out the ideas developed throughout the book. The “Readme” file directs you to the installation instructions and system requirements. &lt;br /&gt;
Acknowledgments: The preparation of the hyperlinked text was made possible by the help of several people at Adobe Inc., in particular Sandra Knox, Sarah Rosenbaum and the FrameMaker Customer Support Group. On the bibliography, Internet sources and exercises &lt;br /&gt;
This book relies on earlier contributions by many authors. To facilitate reading, the discussion of sources appears in most cases not in the course of the discussion, but in the “Bibliographical notes” sections at chapter end. Make sure you read these sections, so as to understand the origin of many ideas and results and find out where to learn more. &lt;br /&gt;
References are of the form Name 19xx, where Name is the name of the first author, and refer to the bibliography in appendix E. This convention is for readability only and is not intended to underrate the role of authors other than the first. The letter M in lieu of a Name denotes publications by the author of this book, listed separately in the second part of the bibliography. &lt;br /&gt;
Aside from the bibliography proper, some references appear in the margin, next to the paragraphs which cite them. The reason for this separate treatment is to make the bibliography usable by itself, as a collection of important references on object technology and related topics. Appearance as a margin reference rather than in the bibliography does not imply any unfavorable judgment of value; the division is simply a pragmatic assessment of what belongs in a core list of object-oriented references. &lt;br /&gt;
&lt;strong&gt;&lt;em&gt; Although electronic references will undoubtedly be considered a matter of course a few years from now, this must be one of the first technical books (other than books devoted to Internet-related topics) to make extensive use of references to World-Wide-Web pages, Usenet newsgroups and other Internet resources. Electronic addresses are notoriously volatile. I have tried to obtain from the authors of the quoted sources some reassurance that the addresses given would remain valid for several years. Neither they nor I, of course, can provide an absolute guarantee. In case of difficulty, note that on the Net more things move than disappear: keyword-based search tools can help. &lt;br /&gt;
&lt;/em&gt;&lt;/strong&gt; Most chapters include exercises of various degrees of difficulty. I have refrained from providing solutions, although many exercises do contain fairly precise hints. Some readers may regret the absence of full solutions; I hope, however, that they will appreciate the three reasons that led to this decision: the fear of spoiling the reader's enjoyment; the realization that many exercises are design problems, for which there is more than one good answer; and the desire to provide a source of ready-made proble ms to instructors using this book as a text. &lt;br /&gt;
*** For brevity and simplicity, the text follows the imperfect but long-established tradition of using words such as “he” and “his” , in reference to unspecified persons, as shortcuts for “he or she” and “his or her” , with no intended connotation of gender.   &lt;/p&gt;
&lt;p&gt;A modest soul is shocked by objects of such kind. And all the nasty thoughts that they bring to one's mind. Moliêre, Tartuffe, Act III   &lt;/p&gt;
&lt;h3&gt;From the Back Cover&lt;/h3&gt;
&lt;p&gt;62915-4 &lt;/p&gt;
&lt;p&gt;The definitive reference on the most important new technology in software! &lt;/p&gt;
&lt;p&gt;“While the original version of OOSC is a classic, OOSC 2/E is destined to overshadow it and all other general introductions . . . literally an epic work.” —James C. McKim, Jr., Hartford Graduate Center &lt;/p&gt;
&lt;p&gt;“Compelling. Extremely well-written and literate . . . I recaptured that same sense of intellectual excitement I felt reading the first edition for the first time.” —Paul Dubois, Lawrence Livermore National Laboratory, Editor, Scientific Programming Dept., Computers in Physics &lt;/p&gt;
&lt;p&gt;“The definitive tome on Object-Orientation . . . the finest piece of writing and thinking about this vast subject . . . Bertrand has a lot to say of great importance and says it well in this significantly revised book.” —Richard Wiener, University of Colorado, Colorado Springs, Editor, Journal for Object-Oriented Programming &lt;/p&gt;
&lt;p&gt;A whole generation was introduced to object technology through the first edition of Bertrand Meyer's OOSC. This long-awaited new edition retains the qualities of clarity, practicality and scholarship that made the first an instant best-seller. It has been thoroughly revised and considerably expanded. No other book on the market provides such a breadth and depth of coverage on the most important technology in software development. &lt;/p&gt;
&lt;p&gt;SOME OF THE NEW TOPICS COVERED IN DEPTH BY THIS SECOND EDITION: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Concurrency, distribution, client-server and the Internet. &lt;/li&gt;
&lt;li&gt;Object-oriented databases, persistence, schema evolution. &lt;/li&gt;
&lt;li&gt;Design by contract: how to build software that works the first time around. &lt;/li&gt;
&lt;li&gt;A study of fundamental design patterns. &lt;/li&gt;
&lt;li&gt;How to find the classes and many others topics of object-oriented methodology. &lt;/li&gt;
&lt;li&gt;How to use inheritance well and detect misuses. &lt;/li&gt;
&lt;li&gt;Abstract data types: the theory behind object technology. &lt;/li&gt;
&lt;li&gt;Typing: role, issues and solutions. &lt;/li&gt;
&lt;li&gt;More than 400 references to books, articles, Web pages, newsgroups; glossary of object technology. &lt;/li&gt;
&lt;li&gt;And many new developments on the topics of the first edition: reusability, modularity, software quality, O-O languages, inheritance techniques, genericity, memory management, etc. &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;About the Author&lt;/h3&gt;
&lt;p&gt;BERTRAND MEYER is one of the pioneers of modern software engineering, whose experience spans both industry and academia. He has led the development of successful O-O products and libraries totaling thousands of classes. His Prentice Hall books include &lt;em&gt;Object Success&lt;/em&gt; (an introduction to object technology for managers), &lt;em&gt;Introduction to the Theory of Programming Languages, Eiffel: The Language, Object-Oriented Applications&lt;/em&gt; , and &lt;em&gt;Reusable Software&lt;/em&gt;. He is a frequent keynote speaker at international conferences and consultant for Fortune 500 companies, editor of the Object-Oriented Series, associate member of the applications section of the French Academy of Sciences, chairman of the TOOLS conference series, and editor of the Object Technology department of IEEE Computer.&lt;/p&gt;
&lt;h3&gt;Excerpt. © Reprinted by permission. All rights reserved.&lt;/h3&gt;
&lt;p&gt;Preface   &lt;/p&gt;
&lt;p&gt;Born in the ice-blue waters of the festooned Norwegian coast; amplified (by an aberration of world currents, for which marine geographers have yet to find a suitable explanation) along the much grayer range of the Californian Pacific; viewed by some as a typhoon, by some as a tsunami, and by some as a storm in a teacup — a tidal wave is hitting the shores of the computing world.   &lt;/p&gt;
&lt;p&gt;“Object-oriented” is the latest in term, complementing and in many cases replacing “structured” as the high-tech version of “good” . As is inevitable in such a case, the term is used by different people with different meanings; just as inevitable is the well-known three-step sequence of reactions that meets the introduction of a new methodological principle: (1) “it's trivial” ; (2) “it cannot work” ; (3) “that's how I did it all along anyway” . (The order may var y.)   &lt;/p&gt;
&lt;p&gt;Let us have this clear right away, lest the reader think the author takes a half-hearted approach to his topic: I do not see the object-oriented method as a mere fad; I think it is not trivial (although I shall strive to make it as limpid as I can); I know it works; and I believe it is not only different from but even, to a certain extent, incompatible with the techniques that most people still use today — including some of the principles taught in many software engineering textbooks. I further believe that object technology holds the potential for fundamental changes in the software industry, and that it is here to stay. Finally, I hope that as the reader progresses through these pages, he will share some of my excitement about this promising avenue to software analysis, design and implementation.   &lt;/p&gt;
&lt;p&gt;“Avenue to software analysis, design and implementation” . To present the object-oriented method, this books resolutely takes the viewpoint of software engineering — of the methods, tools and techniques for developing quality software in production environments. This is not the only possible perspective, as there has also been interest in applying object-oriented principles to such areas as exploratory programming and artificial intelligence. Although the presentation does not exclude these appli cations, they are not its main emphasis. Our principal goal in this discussion is to study how practicing software developers, in industrial as well as academic environments, can use object technology to improve (in some cases dramatically) the quality of the software they produce.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Structure, reliability, epistemology and classification.&lt;/strong&gt; &lt;br /&gt;
Object technology is at its core the combination of four ideas: a structuring method, a reliability discipline, an epistemological principle and a classification technique.   &lt;/p&gt;
&lt;p&gt;The &lt;em&gt;structuring method&lt;/em&gt; applies to software decomposition and reuse. Software systems perform certain actions on objects of certain types; to obtain flexible and reusable systems, it is better to base their structure on the object types than on the actions. The resulting concept is a remarkably powerful and versatile mechanism called the &lt;strong&gt;class,&lt;/strong&gt; which in object-oriented software construction serves as the basis for both the modular structure and the type system.   &lt;/p&gt;
&lt;p&gt;The &lt;em&gt;reliability discipline&lt;/em&gt; is a radical approach to the problem of building software that does what it is supposed to do. The idea is to treat any system as a collection of components which collaborate the way successful businesses do: by adhering to contracts defining explicitly the obligations and benefits incumbent on each party.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Abstract data types are discussed in chapter 6, which also addresses some of the related epistemological issues.&lt;/em&gt; &lt;br /&gt;
The &lt;em&gt;epistemological principle&lt;/em&gt; addresses the question of how we should describe the classes. In object technology, the objects described by a class are only defined by what we can do with them: operations (also known as &lt;em&gt;features&lt;/em&gt; ) and formal properties of these operations (the contracts). This idea is formally expressed by the theory of &lt;strong&gt;abstract data types,&lt;/strong&gt; covered in detail in a chapter of this book. It has far-reaching implications, some going beyond software, and explains why we must not stop at the na•ve concept of “object” borrowed from the ordinary meaning of that word. The tradition of information systems modeling usually assumes an “external reality” that predates any program using it; for the object-oriented developer, such a notion is meaningless, as the reality does not exist independently of what you want to do with it. (More precisely whether it exists or not is an irrelevant question, as we only know what we can use, and what we know of something is defined entire ly by how we can use it.)   &lt;/p&gt;
&lt;p&gt;The &lt;em&gt;classification technique&lt;/em&gt; follows from the observation that systematic intellectual work in general and scientific reasoning in particular require devising taxonomies for the domains being studied. Software is no exception, and the object-oriented method relies heavily on a classification discipline known as &lt;strong&gt;inheritance.&lt;/strong&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Simple but powerful.&lt;/strong&gt; &lt;br /&gt;
The four concepts of class, contract, abstract data type and inheritance immediately raise a number of questions. How do we find and describe classes? How should our programs manipulate classes and the corresponding objects (the &lt;em&gt;instances&lt;/em&gt; of these classes)? What are the possible relations between classes? How can we capitalize on the commonalities that may exist between various classes? How do these ideas relate to such key software engineering concerns as extendibility, ease of use and efficiency?   &lt;/p&gt;
&lt;p&gt;Answers to these questions rely on a small but powerful array of techniques for producing reusable, extendible and reliable software: polymorphism and dynamic binding; a new view of types and type checking; genericity, constrained and unconstrained; information hiding; assertions; safe exception handling; automatic garbage collection. Efficient implementation techniques have been developed which permit applying these ideas successfully to both small and large projects under the tight constraints of commerci al software development. Object-oriented techniques have also had a considerable impact on user interfaces and development environments, making it possible to produce much better interactive systems than was possible before. All these important ideas will be studied in detail, so as to equip the reader with tools that are immediately applicable to a wide range of problems.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Organization of the text.&lt;/strong&gt; &lt;br /&gt;
In the pages that follow we will review the methods and techniques of object-oriented software construction. The presentation has been divided into six parts.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Chapters 1 to 2:&lt;/em&gt; Part A is an introduction and overview. It starts by exploring the fundamental issue of software quality and continues with a brief survey of the method's main technical characteristics. This part is almost a little book by itself, providing a first view of the object-oriented approach for hurried readers.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Chapters 3 to 6:&lt;/em&gt; Part B is not hurried. Entitled “The road to object orientation” , it takes the time to describe the methodological concerns that lead to the central O-O concepts. Its focus is on modularity: what it takes to devise satisfactory structures for “in-the-large” system construction. It ends with a presentation of abstract data types, the mathematical basis for object technology. The mathematics involved is elementary, and less mathematically inclined readers may content themselves with the basic ideas, but the presentation provides the theoretical background that you will need for a full understanding of O-O principles and issues.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Chapters 7 to 18:&lt;/em&gt; Part C is the technical core of the book. It presents, one by one, the central technical components of the method: classes; objects and the associated run-time model; memory management issues; genericity and typing; design by contract, assertions, exceptions; inheritance, the associated concepts of polymorphism and dynamic binding, and their many exciting applications.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Chapters 19 to 29:&lt;/em&gt; Part D discusses methodology, with special emphasis on analysis and design. Through several in-depth case studies, it presents some fundamental design patterns, and covers such central questions as how to find the classes, how to use inheritance properly, and how to design reusable libraries. It starts with a meta-level discussion of the intellectual requirements on methodologists and other advice-givers; it concludes with a review of the software process (the lifecycle model) for O-O development and a disc ussion of how best to teach the method in both industry and universities.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Chapters 30 to 32:&lt;/em&gt; Part E explores advanced topics: concurrency, distribution, client-server development and the Internet; persistence, schema evolution and object-oriented databases; the design of interactive systems with modern (“GUI” ) graphical interfaces.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Chapters 33 to 35.&lt;/em&gt; Part F is a review of how the ideas can be implemented, or in some cases emulated, in various languages and environments. This includes in particular a discussion of major object-oriented languages, focusing on Simula, Smalltalk, Objective-C, C++, Ada 95 and Java, and an assessment of how to obtain some of the benefits of object orientation in such non-O-O languages as Fortran, Cobol, Pascal, C and Ada.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Chapter 36.&lt;/em&gt; Part G (doing it right) describes an environment which goes beyond these solutions and provides an integrated set of tools to support the ideas of the book.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Appendix A.&lt;/em&gt; As complementary reference material, an appendix shows some important reusable library classes discussed in the text, providing a model for the design of reusable software.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Book-Wide Web&lt;/strong&gt; &lt;br /&gt;
It can be amusing to see authors taking pains to describe recommended paths through their books, sometimes with the help of sophisticated traversal charts — as if readers ever paid any attention, and were not smart enough to map their own course. An author is permitted, however, to say in what spirit he has scheduled the different chapters, and what path he had in mind for what Umberto Eco calls the Model Reader — not to be confused with the real reader, also known as “you” , made of flesh, b lood and tastes.   &lt;/p&gt;
&lt;p&gt;The answer here is the simplest possible one. This book tells a story, and assumes that the Model Reader will follow that story from beginning to end, being however invited to avoid the more specialized sections marked as “skippable on first reading” and, if not mathematically inclined, to ignore a few mathematical developments also labeled explicitly. The real reader, of course, may want to discover in advance some of the plot's later developments, or to confine his attention to just a few subplots ; every chapter has for that reason been made as self-contained as possible, so that you should be able to intake the material at the exact dosage which suits you best.   &lt;/p&gt;
&lt;p&gt;Because the story presents a coherent view of software development, its successive topics are tightly intertwined. The margin notes offer a subtext of cross references, a Book-Wide Web linking the various sections back and forth. My advice to the Model Reader is to ignore them on first reading, except as a reassurance that questions which at some stage are left partially open will be fully closed later on. The real reader, who may not want any advice, might use the cross references as unofficial guides when he feels like cheating on the prearranged order of topics.   &lt;/p&gt;
&lt;p&gt;Both the Model Reader and the real reader should find the cross references mostly useful in subsequent readings, to make sure that they have mastered a certain object-oriented concept in depth, and understood its connections with the method's other components. Like the hyperlinks of a WWW document, the cross references should make it possible to follow such associations quickly and effectively.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;See "About the accompanying CD-ROM", page xiv.&lt;/em&gt; The CD-ROM that accompanies this book and contains all of its text provides a convenient way to follow cross references: just click on them. All the cross references have been preserved.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The notation&lt;/strong&gt; &lt;br /&gt;
In software perhaps even more than elsewhere, thought and language are closely connected. As we progress through these pages, we will carefully develop a notation for expressing object-oriented concepts at all levels: modeling, analysis, design, implementation, maintenance.   &lt;/p&gt;
&lt;p&gt;Here and everywhere else in this book, the pronoun “we” does not mean “the author” : as in ordinary language, “we” means you and I — the reader and the author. In other words I would like you to expect that, as we develop the notation, you will be involved in the process.   &lt;/p&gt;
&lt;p&gt;This assumption is not really true, of course, since the notation existed before you started reading these pages. But it is not completely preposterous either, because I hope that as we explore the object-oriented method and carefully examine its implications the supporting notation will dawn on you with a kind of inevitability, so that you will indeed feel that you helped design it.   &lt;/p&gt;
&lt;p&gt;This explains why although the notation has been around for more than ten years and is in fact supported by several commercial implementations, including one from my company (ISE), I have downplayed it as a language. (Its name does appear in one place in the text, and several times in the bibliography.) This book is about the object-oriented method for reusing, analyzing, designing, implementing and maintaining software; the language is an important and I hope natural consequence of that method, not an aim in itself.   &lt;/p&gt;
&lt;p&gt;In addition, the language is straightforward and includes very little else than direct support for the method. First-year students using it have commented that it was “no language at all” — meaning that the notation is in one-to-one correspondence with the method: to learn one is to learn the other, and there is scant extra linguistic decoration on top of the concepts. The notation indeed shows few of the peculiarities (often stemming from historical circumstances, machine constraints or the req uirement to be compatible with older formalisms) that characterize most of today's programming languages. Of course you may disagree with the choice of keywords (why do rather than begin or perhaps faire?), or would like to add semicolon terminators after each instruction. (The syntax has been designed so as to make semicolons optional.) But these are side issues. What counts is the simplicity of the notation and how directly it maps to the concepts. If you understand object technology, you almost know it a lready.   &lt;/p&gt;
&lt;p&gt;Most software books take the language for granted, whether it is a programming language or a notation for analysis or design. Here the approach is different; involving the reader in the design means that one must not only explain the language but also justify it and discuss the alternatives. Most of the chapters of part C include a “discussion” section explaining the issues encountered during the design of the notation, and how they were resolved. I often wished, when reading descriptions of well-kn own languages, that the designers had told me not only what solutions they chose, but why they chose them, and what alternatives they rejected. The candid discussions included in this book should, I hope, provide you with insights not only about language design but also about software construction, as the two tasks are so strikingly similar.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Analysis, design and implementation&lt;/strong&gt; &lt;br /&gt;
It is always risky to use a notation that externally looks like a programming language, as this may suggest that it only covers the implementation phase. This impression, however wrong, is hard to correct, so frequently have managers and developers been told that a gap of metaphysical proportions exists between the ether of analysis-design and the underworld of implementation.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;SEAMLESSNESS AND REVERSIBILITY:, 28.6, page 930.&lt;/em&gt; Well-understood object technology reduces the gap considerably by emphasizing the essential unity of software development over the inevitable differences between levels of abstraction. This seamless approach to software construction is one of the important contributions of the method and is reflected by the language of this book, which is meant for analysis and design as well as for implementation.   &lt;/p&gt;
&lt;p&gt;Unfortunately some of the recent evolution of the field goes against these principles, through two equally regrettable phenomena:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Object-oriented implementation languages which are unfit for analysis, for design and in general for high-level reasoning.   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Object-oriented analysis or design methods which do not cover implementation (and are advertized as “language-independent” as if this were a badge of honor rather than an admission of failure).   &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Such approaches threaten to cancel much of the potential benefit of the approach. In contrast, both the method and the notation developed in this book are meant to be applicable throughout the software construction process. A number of chapters cover high-level design issues; one is devoted to analysis; others explore implementation techniques and the method's implications on performance.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The environment&lt;/strong&gt; &lt;br /&gt;
Software construction relies on a basic tetralogy: method, language, tools, libraries. The method is at the center of this book; the language question has just been mentioned. Once in a while we will need to see what support they may require from tools and libraries. For obvious reasons of convenience, such discussions will occasionally refer to ISE's object-oriented environment, with its set of tools and associated libraries.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;The last chapter, 36, summarizes the environment.&lt;/em&gt; The environment is used only as an example of what can be done to make the concepts practically usable by software developers. Be sure to note that there are many other object-oriented environments available, both for the notation of this book and for other O-O analysis, design and implementation methods and notations; and that the descriptions given refer to the state of the environment at the time of writing, subject, as anything else in our industry, to change quickly — for the better. Other environm ents, O-O and non O-O, are also cited throughout the text.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Acknowledgments (quasi-absence thereof)&lt;/strong&gt; &lt;br /&gt;
The first edition of this book contained an already long list of thanks. For a while I kept writing down the names of people who contributed comments or suggestions, and then at some stage I lost track. The roster of colleagues from whom I have had help or borrowed ideas has now grown so long that it would run over many pages, and would inevitably omit some important people. Better then offend everyone a little than offend a few very much.   &lt;/p&gt;
&lt;p&gt;&lt;em&gt;A few notes in the margin or in chapter-end bibliographic sections give credit for some specific ideas, often unpublished.&lt;/em&gt; So these acknowledgments will for the most part remain collective, which does not make my gratitude less deep. My colleagues at ISE and SOL have for years been a daily source of invaluable help. The users of our tools have generously provided us with their advice. The readers of the first edition provided thousands of suggestions for improvement. In the preparation of this new edition (I should really say of this new book) I have sent hundreds of e-mail messages asking for help of many different kinds: the clarification of a fine point, a bibliographical reference, a permission to quote, the details of an attribution, the origin of an idea, the specifics of a notation, the official address of a Web page; the answers have invariably been positive. As draft chapters were becoming ready they were circulated through various means, prompting many constructive comments (and here I must cite by name the referees commissioned by Prentice Hall, Paul Dubois, James McKim and Richard Wiener, who provided invaluable advic e and corrections). In the past few years I have given countless seminars, lectures and courses about the topics of this book, and in every case I learned something from the audience. I enjoyed the wit of fellow panelists at conferences and benefited from their wisdom. Short sabbaticals at the University of Technology, Sydney and the Universita degli Studi di Milano provided me with a influx of new ideas — and in the first case with three hundred first-year students on whom to validate some of my ideas about how software engineering should be taught.   &lt;/p&gt;
&lt;p&gt;The large bibliography shows clearly enough how the ideas and realizations of others have contributed to this book. Among the most important conscious influences are the Algol line of languages, with its emphasis on syntactic and semantic elegance; the seminal work on structured programming, in the serious (Dijkstra-Hoare-Parnas-Wirth-Mills-Gries) sense of the term, and systematic program construction; formal specification techniques, in particular the inexhaustible lessons of Jean-Raymond Abrial's original (late nineteen-seventies) version of the Z specification language, his more recent design of B, and Cliff Jones's work on VDM; the languages of the modular generation (in particular Ichbiah's Ada, Liskov's CLU, Shaw's Alphard, Bert's LPG and Wirth's Modula); and Simula 67, which introduced most of the concepts many years ago and had most of them right, bringing to mind Tony Hoare's comment about Algol 60: that it was such an improvement over most of its successors.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Foreword to the second edition:&lt;/strong&gt; &lt;br /&gt;
M any events have happened in the object-oriented world since the first edition of OOSC (as the book came to be known) was published in 1988. The explosion of interest alluded to in the Preface to the first edition, reproduced in the preceding pages in a slightly expanded form, was nothing then as compared to what we have seen since. Many journals and conferences now cover object technology; Prentice Hall has an entire book series devoted to the subject; breakthroughs have occurred in such areas as user int erfaces, concurrency and databases; entire new topics have emerged, such as O-O analysis and formal specification; distributed computing, once a specialized topic, is becoming relevant to more and more developments, thanks in part to the growth of the Internet; and the Web is affecting everyone's daily work.   &lt;/p&gt;
&lt;p&gt;This is not the only exciting news. It is gratifying to see how much progress is occurring in the software field — thanks in part to the incomplete but undeniable spread of object technology. Too many books and articles on software engineering still start with the obligatory lament about the “software crisis” and the pitiful state of our industry as compared to true engineering disciplines (which, as we all know, never mess things up). There is no reason for such doom. Oh, we still have a long, long way to go, as anyone who uses software products knows all too well. But given the challenges that we face we have no reason to be ashamed of ourselves as a profession; and we are getting better all the time. It is the ambition of this book, as it was of its predecessor, to help in this process.   &lt;/p&gt;
&lt;p&gt;This second edition is not an update but the result of a thorough reworking. Not a paragraph of the original version has been left untouched. (Hardly a single line, actually.) Countless new topics have been added, including a whole chapter on concurrency, distribution, client-server computing and Internet programming; another on persistence and databases; one on user interfaces; one on the software lifecycle; many design patterns and implementation techniques; an in-depth exploration of a methodological iss ue on which little is available in the literature, how to use inheritance well and avoid misusing it; discussions of many other topics of object-oriented methodology; an extensive presentation of the theory of abstract data types — the mathematical basis for our subject, indispensable to a complete understanding of object technology yet seldom covered in detail by textbooks and tutorials; a presentation of O-O analysis; hundreds of new bibliographic and Web site references; the description of a complete object-oriented development environment (also included on the accompanying CD-ROM for the reader's enjoyment) and of the underlying concepts; and scores of new ideas, principles, caveats, explanations, figures, examples, comparisons, citations, classes, routines.   &lt;/p&gt;
&lt;p&gt;The reactions to OOSC-1 have been so rewarding that I know readers have high expectations. I hope they will find OOSC-2 challenging, useful, and up to their standards. Santa Barbara. &lt;br /&gt;
B.M. January 1997   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;About the accompanying CD-ROM:&lt;/strong&gt; &lt;br /&gt;
The CD-ROM that comes with this book contains the entire hyperlinked text in Adobe Acrobat format. It also includes Adobe's Acrobat Reader software, enabling you to read that format; the versions provided cover major industry platforms. If you do not already have Acrobat Reader on your computer, you can install it by following the instructions. The author and the publisher make no representations as to any property of Acrobat and associated tools; the Acrobat Reader is simply provided as a service to reader s of this book, and any Acrobat questions should be directed to Adobe. You may also check with Adobe about any versions of the Reader that may have appeared after the book.   &lt;/p&gt;
&lt;p&gt;To get started with the CD-ROM, open the Acrobat file README.pdf in the OOSC-2 directory, which will direct you to the table of contents and the index. You can only open that file under Acrobat Reader; if the Reader has not been installed on your computer, examine instead the plain-text version in the file readme.txt in the top-level directory.   &lt;/p&gt;
&lt;p&gt;The presence of an electronic version will be particularly useful to readers who want to take advantage of the thousands of cross-references present in this book (see “A Book-Wide Web” , page viii). Although for a first sequential reading you will probably prefer to follow the paper version, having the electronic form available on a computer next to the book alllows you to follow a link once in a while without having to turn pages back and forth. The electronic form is particularly convenient for a l ater reading during which you may wish to explore links more systematically.   &lt;/p&gt;
&lt;p&gt;All links (cross-references) appear in blue in the Acrobat form, as illustrated twice above (but not visible in the printed version). To follow a link, just click on the blue part. If the reference is to another chapter, the chapter will appear in a new window. The Acrobat Reader command to come back to the previous position is normally Control-minus-sign (that is, type Ð while holding down the CONTROL key). Consult the on-line Acrobat Reader documentation for other useful navigational commands.   &lt;/p&gt;
&lt;p&gt;Bibliographical references also appear as links, such as Knuth 1968, in the Acrobat form, so that you can click on any of them to see the corresponding entry in the bibliography of appendix E. &lt;br /&gt;
&lt;strong&gt;The CD-ROM also contains:&lt;/strong&gt;   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;Library components providing extensive material for Appendix A. &lt;/li&gt;
&lt;li&gt;A chapter from the manual for a graphical application builder, providing mathematical complements to the material of chapter 32. &lt;br /&gt;
In addition, the CD-ROM includes a time-limited version of an advanced object-oriented development environment for Windows 95 or Windows NT, as described in chapter 36, providing an excellent hands-on opportunity to try out the ideas developed throughout the book. The “Readme” file directs you to the installation instructions and system requirements. &lt;br /&gt;
Acknowledgments: The preparation of the hyperlinked text was made possible by the help of several people at Adobe Inc., in particular Sandra Knox, Sarah Rosenbaum and the FrameMaker Customer Support Group. On the bibliography, Internet sources and exercises &lt;br /&gt;
This book relies on earlier contributions by many authors. To facilitate reading, the discussion of sources appears in most cases not in the course of the discussion, but in the “Bibliographical notes” sections at chapter end. Make sure you read these sections, so as to understand the origin of many ideas and results and find out where to learn more. &lt;br /&gt;
References are of the form Name 19xx, where Name is the name of the first author, and refer to the bibliography in appendix E. This convention is for readability only and is not intended to underrate the role of authors other than the first. The letter M in lieu of a Name denotes publications by the author of this book, listed separately in the second part of the bibliography. &lt;br /&gt;
Aside from the bibliography proper, some references appear in the margin, next to the paragraphs which cite them. The reason for this separate treatment is to make the bibliography usable by itself, as a collection of important references on object technology and related topics. Appearance as a margin reference rather than in the bibliography does not imply any unfavorable judgment of value; the division is simply a pragmatic assessment of what belongs in a core list of object-oriented references. &lt;br /&gt;
&lt;strong&gt;&lt;em&gt; Although electronic references will undoubtedly be considered a matter of course a few years from now, this must be one of the first technical books (other than books devoted to Internet-related topics) to make extensive use of references to World-Wide-Web pages, Usenet newsgroups and other Internet resources. Electronic addresses are notoriously volatile. I have tried to obtain from the authors of the quoted sources some reassurance that the addresses given would remain valid for several years. Neither they nor I, of course, can provide an absolute guarantee. In case of difficulty, note that on the Net more things move than disappear: keyword-based search tools can help. &lt;br /&gt;
&lt;/em&gt;&lt;/strong&gt; Most chapters include exercises of various degrees of difficulty. I have refrained from providing solutions, although many exercises do contain fairly precise hints. Some readers may regret the absence of full solutions; I hope, however, that they will appreciate the three reasons that led to this decision: the fear of spoiling the reader's enjoyment; the realization that many exercises are design problems, for which there is more than one good answer; and the desire to provide a source of ready-made proble ms to instructors using this book as a text. &lt;br /&gt;
*** For brevity and simplicity, the text follows the imperfect but long-established tradition of using words such as “he” and “his” , in reference to unspecified persons, as shortcuts for “he or she” and “his or her” , with no intended connotation of gender.   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A modest soul is shocked by objects of such kind. And all the nasty thoughts that they bring to one's mind. Moliêre, Tartuffe, Act III   &lt;/p&gt;</dc:description>
        <dc:publisher>Pearson College Div</dc:publisher>
        <dc:identifier opf:scheme="AMAZON">0136291554</dc:identifier>
        <dc:identifier opf:scheme="ISBN">9780136291558</dc:identifier>
        <dc:language>eng</dc:language>
        <dc:subject>oop</dc:subject>
        <dc:subject>objects</dc:subject>
        <meta name="calibre:author_link_map" content="{&quot;Bertrand Meyer&quot;: &quot;&quot;}"/>
        <meta name="calibre:rating" content="10"/>
        <meta name="calibre:timestamp" content="2023-03-09T21:22:04+00:00"/>
        <meta name="calibre:title_sort" content="Object-Oriented Software Construction"/>
        <meta name="calibre:user_metadata:#lastopened" content="{&quot;table&quot;: &quot;custom_column_1&quot;, &quot;column&quot;: &quot;value&quot;, &quot;datatype&quot;: &quot;datetime&quot;, &quot;is_multiple&quot;: null, &quot;kind&quot;: &quot;field&quot;, &quot;name&quot;: &quot;lastopened&quot;, &quot;search_terms&quot;: [&quot;#lastopened&quot;], &quot;label&quot;: &quot;lastopened&quot;, &quot;colnum&quot;: 1, &quot;display&quot;: {&quot;date_format&quot;: null, &quot;description&quot;: &quot;&quot;}, &quot;is_custom&quot;: true, &quot;is_category&quot;: false, &quot;link_column&quot;: &quot;value&quot;, &quot;category_sort&quot;: &quot;value&quot;, &quot;is_csp&quot;: false, &quot;is_editable&quot;: true, &quot;rec_index&quot;: 22, &quot;#value#&quot;: {&quot;__class__&quot;: &quot;datetime.datetime&quot;, &quot;__value__&quot;: &quot;2023-03-10T11:01:59.453862+00:00&quot;}, &quot;#extra#&quot;: null, &quot;is_multiple2&quot;: {}}"/>
    </metadata>
    <guide>
        <reference type="cover" title="Cover" href="cover.jpg"/>
    </guide>
</package>
